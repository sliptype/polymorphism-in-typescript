{"componentChunkName":"component---node-modules-gatsby-theme-mdx-deck-src-templates-deck-js","path":"/print","result":{"data":{"deck":{"id":"97c449b9-8404-5627-8399-2a245f6c4575","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar theme = nightOwl;\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  theme: theme,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Polymorphism in TypeScript\"), mdx(\"span\", null, mdx(\"a\", {\n    href: \"https://github.com/sliptype\"\n  }, \"@sliptype\"), mdx(\"span\", {\n    style: {\n      marginLeft: '1rem',\n      marginRight: '1rem'\n    }\n  }, \"|\"), mdx(\"a\", {\n    href: \"https://codesandbox.io/s/polymorphism-in-typescript-pwqx3\"\n  }, \"get the code\")), mdx(\"hr\", null), mdx(Definition, {\n    syllables: ['Type', 'Script'],\n    type: 'noun',\n    definition: 'a strict syntactical superset of JavaScript whichs adds optional static typing to the language.',\n    mdxType: \"Definition\"\n  }), mdx(\"hr\", null), mdx(Definition, {\n    syllables: ['pol', 'y', 'morph', 'ism'],\n    type: 'noun',\n    definition: 'the condition of occurring in several different forms.',\n    mdxType: \"Definition\"\n  }), mdx(\"hr\", null), mdx(Definition, {\n    syllables: ['pol', 'y', 'morph', 'ism'],\n    type: 'noun',\n    definition: 'the provision of a single interface to entities of different types or the use of a single symbol to represent multiple different types.',\n    mdxType: \"Definition\"\n  }), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"title=\\\"Type Signatures\\\" subtitle=\\\"Define the inputs and outputs for a function\\\"\",\n    \"title\": \"\\\"Type\",\n    \"Signatures\\\"\": true,\n    \"subtitle\": \"\\\"Define\",\n    \"the\": true,\n    \"inputs\": true,\n    \"and\": true,\n    \"outputs\": true,\n    \"for\": true,\n    \"a\": true,\n    \"function\\\"\": true\n  }), \"  const identity = (\\n    a: string\\n  ): string => a\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"title=\\\"Monomorphic Functions\\\" subtitle=\\\"Have a large implementation space\\\"\",\n    \"title\": \"\\\"Monomorphic\",\n    \"Functions\\\"\": true,\n    \"subtitle\": \"\\\"Have\",\n    \"a\": true,\n    \"large\": true,\n    \"implementation\": true,\n    \"space\\\"\": true\n  }), \"  const identity = (\\n    a: string\\n  ): string => 'Hello, Mr. Bug'\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"title=\\\"Monomorphic Functions\\\" subtitle=\\\"Duplicate logic for multiple data types\\\"\",\n    \"title\": \"\\\"Monomorphic\",\n    \"Functions\\\"\": true,\n    \"subtitle\": \"\\\"Duplicate\",\n    \"logic\": true,\n    \"for\": true,\n    \"multiple\": true,\n    \"data\": true,\n    \"types\\\"\": true\n  }), \"  const identity = (\\n    a: number\\n  ): number => a\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"title=\\\"Type Parameters\\\" subtitle=\\\"Allow for a more generic implementation of the function\\\"\",\n    \"title\": \"\\\"Type\",\n    \"Parameters\\\"\": true,\n    \"subtitle\": \"\\\"Allow\",\n    \"for\": true,\n    \"a\": true,\n    \"more\": true,\n    \"generic\": true,\n    \"implementation\": true,\n    \"of\": true,\n    \"the\": true,\n    \"function\\\"\": true\n  }), \"  const identity = <T>(\\n    a: T\\n  ): T => a\\n\"))), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    themes: [github, nightOwl],\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"1:4 title=\\\"Monomorphic Functions\\\"\",\n    \"1:4\": true,\n    \"title\": \"\\\"Monomorphic\",\n    \"Functions\\\"\": true\n  }), \"const appendString = (\\n  beginning: string,\\n  end: string\\n): string => beginning + \\\"Mr. Bug, \\\" + end;\\n\\nconsole.log(appendString(\\\"hello \\\", \\\"how are you?\\\"));\\n\")), mdx(Text, {\n    mdxType: \"Text\"\n  }, \"When types are concrete, we often have to break the abstraction and look inside the function to know that it's name is not lying to us.\")), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"6:7 title=\\\"Monomorphic Functions\\\"\",\n    \"6:7\": true,\n    \"title\": \"\\\"Monomorphic\",\n    \"Functions\\\"\": true\n  }), \"const appendString = (\\n  beginning: string,\\n  end: string\\n): string => beginning + \\\"Mr. Bug, \\\" + end;\\n\\nconsole.log(appendString(\\\"hello \\\", \\\"how are you?\\\"));\\n// \\\"hello Mr. Bug, how are you?\\\"\\n\")), mdx(Text, {\n    mdxType: \"Text\"\n  }, \"Knowing more about the types in our signature means we know less about the implementation of our function.\"))), mdx(\"hr\", null), mdx(Text, {\n    mdxType: \"Text\"\n  }, mdx(\"p\", null, \"  Require the least powerful interface you need to implement a function.\")), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    themes: [nightOwl, nightOwl],\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"All we really need to know about the argument for \", mdx(Code, {\n    mdxType: \"Code\"\n  }, \"appendString\"), \" is that it is appendable.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"1:3 file=./polymorphism.ts title=\\\"Appendable Interface\\\"\",\n    \"1:3\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Appendable\",\n    \"Interface\\\"\": true\n  }), \"interface Appendable<T> {\\n  append(a: Appendable<T>): Appendable<T>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  a: Type,\\n  b: Type\\n): Type => a.append(b) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(a: _String): _String {\\n    return new _String(`${this.value}${a.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(a: _Number): _Number {\\n    return new _Number(this.value + a.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <T, U>(\\n  fn: (a: T) => U,\\n  array: T[]\\n): U[] => [fn(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (a: number) => String.fromCharCode(a),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<T> {\\n  map<U>(f: (x: T) => U): Mappable<U>;\\n}\\n\\ninterface Reducable<T> {\\n  reduce<U>(f: (a: U, b: T) => U, a: U): U;\\n}\\n\\nclass _List<T>\\n  implements Appendable<_List<T>>, Mappable<T>, Reducable<T> {\\n  public value: T[];\\n\\n  constructor(value: T[]) {\\n    this.value = value;\\n  }\\n\\n  append(a: _List<T>): _List<T> {\\n    return new _List([...this.value, ...a.value]);\\n  }\\n\\n  map<U>(f: (x: T) => U) {\\n    return this.value.map(f);\\n  }\\n\\n  reduce<U>(f: (x: U, y: T) => U, a: U) {\\n    return this.value.reduce(f, a);\\n  }\\n}\\n\\nconst mapPolymorphic = <T, U>(\\n  fn: (a: T) => U,\\n  xs: Mappable<T>\\n): Mappable<U> => xs.map(fn);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (a: number) => String.fromCharCode(a),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <T, U>(\\n  reducer: (accumulator: U, current: T) => U,\\n  initialValue: U,\\n  array: T[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, current: string) =>\\n      current.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\nconst reducePolymorphic = <R extends Reducable<T>, T, U>(\\n  fn: (x: U, y: T) => U,\\n  a: U,\\n  xs: R\\n) => xs.reduce(fn, a);\\n\\nconsole.log(\\n  reducePolymorphic(\\n    (a: number, b: string) => b.charCodeAt(0) + a,\\n    0,\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"This function only has four possible implementations!\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"5:8 file=./polymorphism.ts title=\\\"Polymorphic Append\\\"\",\n    \"5:8\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Polymorphic\",\n    \"Append\\\"\": true\n  }), \"interface Appendable<T> {\\n  append(a: Appendable<T>): Appendable<T>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  a: Type,\\n  b: Type\\n): Type => a.append(b) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(a: _String): _String {\\n    return new _String(`${this.value}${a.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(a: _Number): _Number {\\n    return new _Number(this.value + a.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <T, U>(\\n  fn: (a: T) => U,\\n  array: T[]\\n): U[] => [fn(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (a: number) => String.fromCharCode(a),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<T> {\\n  map<U>(f: (x: T) => U): Mappable<U>;\\n}\\n\\ninterface Reducable<T> {\\n  reduce<U>(f: (a: U, b: T) => U, a: U): U;\\n}\\n\\nclass _List<T>\\n  implements Appendable<_List<T>>, Mappable<T>, Reducable<T> {\\n  public value: T[];\\n\\n  constructor(value: T[]) {\\n    this.value = value;\\n  }\\n\\n  append(a: _List<T>): _List<T> {\\n    return new _List([...this.value, ...a.value]);\\n  }\\n\\n  map<U>(f: (x: T) => U) {\\n    return this.value.map(f);\\n  }\\n\\n  reduce<U>(f: (x: U, y: T) => U, a: U) {\\n    return this.value.reduce(f, a);\\n  }\\n}\\n\\nconst mapPolymorphic = <T, U>(\\n  fn: (a: T) => U,\\n  xs: Mappable<T>\\n): Mappable<U> => xs.map(fn);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (a: number) => String.fromCharCode(a),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <T, U>(\\n  reducer: (accumulator: U, current: T) => U,\\n  initialValue: U,\\n  array: T[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, current: string) =>\\n      current.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\nconst reducePolymorphic = <R extends Reducable<T>, T, U>(\\n  fn: (x: U, y: T) => U,\\n  a: U,\\n  xs: R\\n) => xs.reduce(fn, a);\\n\\nconsole.log(\\n  reducePolymorphic(\\n    (a: number, b: string) => b.charCodeAt(0) + a,\\n    0,\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"TypeScript enables us to implement this interface for our own \", mdx(Code, {\n    mdxType: \"Code\"\n  }, \"_String\"), \" type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"10:20 file=./polymorphism.ts title=\\\"Implementing Appendable\\\"\",\n    \"10:20\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Implementing\",\n    \"Appendable\\\"\": true\n  }), \"interface Appendable<T> {\\n  append(a: Appendable<T>): Appendable<T>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  a: Type,\\n  b: Type\\n): Type => a.append(b) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(a: _String): _String {\\n    return new _String(`${this.value}${a.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(a: _Number): _Number {\\n    return new _Number(this.value + a.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <T, U>(\\n  fn: (a: T) => U,\\n  array: T[]\\n): U[] => [fn(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (a: number) => String.fromCharCode(a),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<T> {\\n  map<U>(f: (x: T) => U): Mappable<U>;\\n}\\n\\ninterface Reducable<T> {\\n  reduce<U>(f: (a: U, b: T) => U, a: U): U;\\n}\\n\\nclass _List<T>\\n  implements Appendable<_List<T>>, Mappable<T>, Reducable<T> {\\n  public value: T[];\\n\\n  constructor(value: T[]) {\\n    this.value = value;\\n  }\\n\\n  append(a: _List<T>): _List<T> {\\n    return new _List([...this.value, ...a.value]);\\n  }\\n\\n  map<U>(f: (x: T) => U) {\\n    return this.value.map(f);\\n  }\\n\\n  reduce<U>(f: (x: U, y: T) => U, a: U) {\\n    return this.value.reduce(f, a);\\n  }\\n}\\n\\nconst mapPolymorphic = <T, U>(\\n  fn: (a: T) => U,\\n  xs: Mappable<T>\\n): Mappable<U> => xs.map(fn);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (a: number) => String.fromCharCode(a),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <T, U>(\\n  reducer: (accumulator: U, current: T) => U,\\n  initialValue: U,\\n  array: T[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, current: string) =>\\n      current.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\nconst reducePolymorphic = <R extends Reducable<T>, T, U>(\\n  fn: (x: U, y: T) => U,\\n  a: U,\\n  xs: R\\n) => xs.reduce(fn, a);\\n\\nconsole.log(\\n  reducePolymorphic(\\n    (a: number, b: string) => b.charCodeAt(0) + a,\\n    0,\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"This results in a function that has more utility and fewer possible implementations.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"22:28 file=./polymorphism.ts title=\\\"Polymorphic Append\\\"\",\n    \"22:28\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Polymorphic\",\n    \"Append\\\"\": true\n  }), \"interface Appendable<T> {\\n  append(a: Appendable<T>): Appendable<T>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  a: Type,\\n  b: Type\\n): Type => a.append(b) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(a: _String): _String {\\n    return new _String(`${this.value}${a.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(a: _Number): _Number {\\n    return new _Number(this.value + a.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <T, U>(\\n  fn: (a: T) => U,\\n  array: T[]\\n): U[] => [fn(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (a: number) => String.fromCharCode(a),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<T> {\\n  map<U>(f: (x: T) => U): Mappable<U>;\\n}\\n\\ninterface Reducable<T> {\\n  reduce<U>(f: (a: U, b: T) => U, a: U): U;\\n}\\n\\nclass _List<T>\\n  implements Appendable<_List<T>>, Mappable<T>, Reducable<T> {\\n  public value: T[];\\n\\n  constructor(value: T[]) {\\n    this.value = value;\\n  }\\n\\n  append(a: _List<T>): _List<T> {\\n    return new _List([...this.value, ...a.value]);\\n  }\\n\\n  map<U>(f: (x: T) => U) {\\n    return this.value.map(f);\\n  }\\n\\n  reduce<U>(f: (x: U, y: T) => U, a: U) {\\n    return this.value.reduce(f, a);\\n  }\\n}\\n\\nconst mapPolymorphic = <T, U>(\\n  fn: (a: T) => U,\\n  xs: Mappable<T>\\n): Mappable<U> => xs.map(fn);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (a: number) => String.fromCharCode(a),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <T, U>(\\n  reducer: (accumulator: U, current: T) => U,\\n  initialValue: U,\\n  array: T[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, current: string) =>\\n      current.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\nconst reducePolymorphic = <R extends Reducable<T>, T, U>(\\n  fn: (x: U, y: T) => U,\\n  a: U,\\n  xs: R\\n) => xs.reduce(fn, a);\\n\\nconsole.log(\\n  reducePolymorphic(\\n    (a: number, b: string) => b.charCodeAt(0) + a,\\n    0,\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"We can give any type of data the \\\"appendability\\\" property by implementing the interface.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"30:40 file=./polymorphism.ts title=\\\"Implementing Appendable\\\"\",\n    \"30:40\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Implementing\",\n    \"Appendable\\\"\": true\n  }), \"interface Appendable<T> {\\n  append(a: Appendable<T>): Appendable<T>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  a: Type,\\n  b: Type\\n): Type => a.append(b) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(a: _String): _String {\\n    return new _String(`${this.value}${a.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(a: _Number): _Number {\\n    return new _Number(this.value + a.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <T, U>(\\n  fn: (a: T) => U,\\n  array: T[]\\n): U[] => [fn(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (a: number) => String.fromCharCode(a),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<T> {\\n  map<U>(f: (x: T) => U): Mappable<U>;\\n}\\n\\ninterface Reducable<T> {\\n  reduce<U>(f: (a: U, b: T) => U, a: U): U;\\n}\\n\\nclass _List<T>\\n  implements Appendable<_List<T>>, Mappable<T>, Reducable<T> {\\n  public value: T[];\\n\\n  constructor(value: T[]) {\\n    this.value = value;\\n  }\\n\\n  append(a: _List<T>): _List<T> {\\n    return new _List([...this.value, ...a.value]);\\n  }\\n\\n  map<U>(f: (x: T) => U) {\\n    return this.value.map(f);\\n  }\\n\\n  reduce<U>(f: (x: U, y: T) => U, a: U) {\\n    return this.value.reduce(f, a);\\n  }\\n}\\n\\nconst mapPolymorphic = <T, U>(\\n  fn: (a: T) => U,\\n  xs: Mappable<T>\\n): Mappable<U> => xs.map(fn);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (a: number) => String.fromCharCode(a),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <T, U>(\\n  reducer: (accumulator: U, current: T) => U,\\n  initialValue: U,\\n  array: T[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, current: string) =>\\n      current.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\nconst reducePolymorphic = <R extends Reducable<T>, T, U>(\\n  fn: (x: U, y: T) => U,\\n  a: U,\\n  xs: R\\n) => xs.reduce(fn, a);\\n\\nconsole.log(\\n  reducePolymorphic(\\n    (a: number, b: string) => b.charCodeAt(0) + a,\\n    0,\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"This allows reuse of our function.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"41:48 file=./polymorphism.ts title=\\\"Polymorphic Append\\\"\",\n    \"41:48\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Polymorphic\",\n    \"Append\\\"\": true\n  }), \"interface Appendable<T> {\\n  append(a: Appendable<T>): Appendable<T>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  a: Type,\\n  b: Type\\n): Type => a.append(b) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(a: _String): _String {\\n    return new _String(`${this.value}${a.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(a: _Number): _Number {\\n    return new _Number(this.value + a.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <T, U>(\\n  fn: (a: T) => U,\\n  array: T[]\\n): U[] => [fn(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (a: number) => String.fromCharCode(a),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<T> {\\n  map<U>(f: (x: T) => U): Mappable<U>;\\n}\\n\\ninterface Reducable<T> {\\n  reduce<U>(f: (a: U, b: T) => U, a: U): U;\\n}\\n\\nclass _List<T>\\n  implements Appendable<_List<T>>, Mappable<T>, Reducable<T> {\\n  public value: T[];\\n\\n  constructor(value: T[]) {\\n    this.value = value;\\n  }\\n\\n  append(a: _List<T>): _List<T> {\\n    return new _List([...this.value, ...a.value]);\\n  }\\n\\n  map<U>(f: (x: T) => U) {\\n    return this.value.map(f);\\n  }\\n\\n  reduce<U>(f: (x: U, y: T) => U, a: U) {\\n    return this.value.reduce(f, a);\\n  }\\n}\\n\\nconst mapPolymorphic = <T, U>(\\n  fn: (a: T) => U,\\n  xs: Mappable<T>\\n): Mappable<U> => xs.map(fn);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (a: number) => String.fromCharCode(a),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <T, U>(\\n  reducer: (accumulator: U, current: T) => U,\\n  initialValue: U,\\n  array: T[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, current: string) =>\\n      current.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\nconst reducePolymorphic = <R extends Reducable<T>, T, U>(\\n  fn: (x: U, y: T) => U,\\n  a: U,\\n  xs: R\\n) => xs.reduce(fn, a);\\n\\nconsole.log(\\n  reducePolymorphic(\\n    (a: number, b: string) => b.charCodeAt(0) + a,\\n    0,\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"Fully specifying container types, like arrays, also presents problems.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"50:62 file=./polymorphism.ts title=\\\"Monomorphic Map\\\"\",\n    \"50:62\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Monomorphic\",\n    \"Map\\\"\": true\n  }), \"interface Appendable<T> {\\n  append(a: Appendable<T>): Appendable<T>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  a: Type,\\n  b: Type\\n): Type => a.append(b) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(a: _String): _String {\\n    return new _String(`${this.value}${a.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(a: _Number): _Number {\\n    return new _Number(this.value + a.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <T, U>(\\n  fn: (a: T) => U,\\n  array: T[]\\n): U[] => [fn(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (a: number) => String.fromCharCode(a),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<T> {\\n  map<U>(f: (x: T) => U): Mappable<U>;\\n}\\n\\ninterface Reducable<T> {\\n  reduce<U>(f: (a: U, b: T) => U, a: U): U;\\n}\\n\\nclass _List<T>\\n  implements Appendable<_List<T>>, Mappable<T>, Reducable<T> {\\n  public value: T[];\\n\\n  constructor(value: T[]) {\\n    this.value = value;\\n  }\\n\\n  append(a: _List<T>): _List<T> {\\n    return new _List([...this.value, ...a.value]);\\n  }\\n\\n  map<U>(f: (x: T) => U) {\\n    return this.value.map(f);\\n  }\\n\\n  reduce<U>(f: (x: U, y: T) => U, a: U) {\\n    return this.value.reduce(f, a);\\n  }\\n}\\n\\nconst mapPolymorphic = <T, U>(\\n  fn: (a: T) => U,\\n  xs: Mappable<T>\\n): Mappable<U> => xs.map(fn);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (a: number) => String.fromCharCode(a),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <T, U>(\\n  reducer: (accumulator: U, current: T) => U,\\n  initialValue: U,\\n  array: T[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, current: string) =>\\n      current.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\nconst reducePolymorphic = <R extends Reducable<T>, T, U>(\\n  fn: (x: U, y: T) => U,\\n  a: U,\\n  xs: R\\n) => xs.reduce(fn, a);\\n\\nconsole.log(\\n  reducePolymorphic(\\n    (a: number, b: string) => b.charCodeAt(0) + a,\\n    0,\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"An array is one of many types that can be mapped.\", mdx(\"div\", {\n    style: {\n      marginTop: '2rem',\n      textAlign: 'left'\n    }\n  }, \"Others include:\", mdx(\"ul\", null, mdx(\"li\", null, \"Object\"), mdx(\"li\", null, \"Tree\"), mdx(\"li\", null, \"Tuple\")))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"63:66 file=./polymorphism.ts title=\\\"Mappable Interface\\\"\",\n    \"63:66\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Mappable\",\n    \"Interface\\\"\": true\n  }), \"interface Appendable<T> {\\n  append(a: Appendable<T>): Appendable<T>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  a: Type,\\n  b: Type\\n): Type => a.append(b) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(a: _String): _String {\\n    return new _String(`${this.value}${a.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(a: _Number): _Number {\\n    return new _Number(this.value + a.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <T, U>(\\n  fn: (a: T) => U,\\n  array: T[]\\n): U[] => [fn(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (a: number) => String.fromCharCode(a),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<T> {\\n  map<U>(f: (x: T) => U): Mappable<U>;\\n}\\n\\ninterface Reducable<T> {\\n  reduce<U>(f: (a: U, b: T) => U, a: U): U;\\n}\\n\\nclass _List<T>\\n  implements Appendable<_List<T>>, Mappable<T>, Reducable<T> {\\n  public value: T[];\\n\\n  constructor(value: T[]) {\\n    this.value = value;\\n  }\\n\\n  append(a: _List<T>): _List<T> {\\n    return new _List([...this.value, ...a.value]);\\n  }\\n\\n  map<U>(f: (x: T) => U) {\\n    return this.value.map(f);\\n  }\\n\\n  reduce<U>(f: (x: U, y: T) => U, a: U) {\\n    return this.value.reduce(f, a);\\n  }\\n}\\n\\nconst mapPolymorphic = <T, U>(\\n  fn: (a: T) => U,\\n  xs: Mappable<T>\\n): Mappable<U> => xs.map(fn);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (a: number) => String.fromCharCode(a),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <T, U>(\\n  reducer: (accumulator: U, current: T) => U,\\n  initialValue: U,\\n  array: T[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, current: string) =>\\n      current.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\nconst reducePolymorphic = <R extends Reducable<T>, T, U>(\\n  fn: (x: U, y: T) => U,\\n  a: U,\\n  xs: R\\n) => xs.reduce(fn, a);\\n\\nconsole.log(\\n  reducePolymorphic(\\n    (a: number, b: string) => b.charCodeAt(0) + a,\\n    0,\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"To make use of this, we can create a \", mdx(Code, {\n    mdxType: \"Code\"\n  }, \"_List\"), \" code that implements \", mdx(Code, {\n    mdxType: \"Code\"\n  }, \"Appendable\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"71:90 file=./polymorphism.ts title=\\\"Implementing Mappable\\\"\",\n    \"71:90\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Implementing\",\n    \"Mappable\\\"\": true\n  }), \"interface Appendable<T> {\\n  append(a: Appendable<T>): Appendable<T>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  a: Type,\\n  b: Type\\n): Type => a.append(b) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(a: _String): _String {\\n    return new _String(`${this.value}${a.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(a: _Number): _Number {\\n    return new _Number(this.value + a.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <T, U>(\\n  fn: (a: T) => U,\\n  array: T[]\\n): U[] => [fn(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (a: number) => String.fromCharCode(a),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<T> {\\n  map<U>(f: (x: T) => U): Mappable<U>;\\n}\\n\\ninterface Reducable<T> {\\n  reduce<U>(f: (a: U, b: T) => U, a: U): U;\\n}\\n\\nclass _List<T>\\n  implements Appendable<_List<T>>, Mappable<T>, Reducable<T> {\\n  public value: T[];\\n\\n  constructor(value: T[]) {\\n    this.value = value;\\n  }\\n\\n  append(a: _List<T>): _List<T> {\\n    return new _List([...this.value, ...a.value]);\\n  }\\n\\n  map<U>(f: (x: T) => U) {\\n    return this.value.map(f);\\n  }\\n\\n  reduce<U>(f: (x: U, y: T) => U, a: U) {\\n    return this.value.reduce(f, a);\\n  }\\n}\\n\\nconst mapPolymorphic = <T, U>(\\n  fn: (a: T) => U,\\n  xs: Mappable<T>\\n): Mappable<U> => xs.map(fn);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (a: number) => String.fromCharCode(a),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <T, U>(\\n  reducer: (accumulator: U, current: T) => U,\\n  initialValue: U,\\n  array: T[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, current: string) =>\\n      current.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\nconst reducePolymorphic = <R extends Reducable<T>, T, U>(\\n  fn: (x: U, y: T) => U,\\n  a: U,\\n  xs: R\\n) => xs.reduce(fn, a);\\n\\nconsole.log(\\n  reducePolymorphic(\\n    (a: number, b: string) => b.charCodeAt(0) + a,\\n    0,\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"This function only has one possible implementation!\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"92:95 file=./polymorphism.ts title=\\\"Polymorphic Map\\\"\",\n    \"92:95\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Polymorphic\",\n    \"Map\\\"\": true\n  }), \"interface Appendable<T> {\\n  append(a: Appendable<T>): Appendable<T>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  a: Type,\\n  b: Type\\n): Type => a.append(b) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(a: _String): _String {\\n    return new _String(`${this.value}${a.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(a: _Number): _Number {\\n    return new _Number(this.value + a.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <T, U>(\\n  fn: (a: T) => U,\\n  array: T[]\\n): U[] => [fn(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (a: number) => String.fromCharCode(a),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<T> {\\n  map<U>(f: (x: T) => U): Mappable<U>;\\n}\\n\\ninterface Reducable<T> {\\n  reduce<U>(f: (a: U, b: T) => U, a: U): U;\\n}\\n\\nclass _List<T>\\n  implements Appendable<_List<T>>, Mappable<T>, Reducable<T> {\\n  public value: T[];\\n\\n  constructor(value: T[]) {\\n    this.value = value;\\n  }\\n\\n  append(a: _List<T>): _List<T> {\\n    return new _List([...this.value, ...a.value]);\\n  }\\n\\n  map<U>(f: (x: T) => U) {\\n    return this.value.map(f);\\n  }\\n\\n  reduce<U>(f: (x: U, y: T) => U, a: U) {\\n    return this.value.reduce(f, a);\\n  }\\n}\\n\\nconst mapPolymorphic = <T, U>(\\n  fn: (a: T) => U,\\n  xs: Mappable<T>\\n): Mappable<U> => xs.map(fn);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (a: number) => String.fromCharCode(a),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <T, U>(\\n  reducer: (accumulator: U, current: T) => U,\\n  initialValue: U,\\n  array: T[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, current: string) =>\\n      current.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\nconst reducePolymorphic = <R extends Reducable<T>, T, U>(\\n  fn: (x: U, y: T) => U,\\n  a: U,\\n  xs: R\\n) => xs.reduce(fn, a);\\n\\nconsole.log(\\n  reducePolymorphic(\\n    (a: number, b: string) => b.charCodeAt(0) + a,\\n    0,\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"The implementation space is reduced f rom infinity to 1.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"97:103 file=./polymorphism.ts title=\\\"Polymorphic Map\\\"\",\n    \"97:103\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Polymorphic\",\n    \"Map\\\"\": true\n  }), \"interface Appendable<T> {\\n  append(a: Appendable<T>): Appendable<T>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  a: Type,\\n  b: Type\\n): Type => a.append(b) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(a: _String): _String {\\n    return new _String(`${this.value}${a.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(a: _Number): _Number {\\n    return new _Number(this.value + a.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <T, U>(\\n  fn: (a: T) => U,\\n  array: T[]\\n): U[] => [fn(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (a: number) => String.fromCharCode(a),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<T> {\\n  map<U>(f: (x: T) => U): Mappable<U>;\\n}\\n\\ninterface Reducable<T> {\\n  reduce<U>(f: (a: U, b: T) => U, a: U): U;\\n}\\n\\nclass _List<T>\\n  implements Appendable<_List<T>>, Mappable<T>, Reducable<T> {\\n  public value: T[];\\n\\n  constructor(value: T[]) {\\n    this.value = value;\\n  }\\n\\n  append(a: _List<T>): _List<T> {\\n    return new _List([...this.value, ...a.value]);\\n  }\\n\\n  map<U>(f: (x: T) => U) {\\n    return this.value.map(f);\\n  }\\n\\n  reduce<U>(f: (x: U, y: T) => U, a: U) {\\n    return this.value.reduce(f, a);\\n  }\\n}\\n\\nconst mapPolymorphic = <T, U>(\\n  fn: (a: T) => U,\\n  xs: Mappable<T>\\n): Mappable<U> => xs.map(fn);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (a: number) => String.fromCharCode(a),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <T, U>(\\n  reducer: (accumulator: U, current: T) => U,\\n  initialValue: U,\\n  array: T[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, current: string) =>\\n      current.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\nconst reducePolymorphic = <R extends Reducable<T>, T, U>(\\n  fn: (x: U, y: T) => U,\\n  a: U,\\n  xs: R\\n) => xs.reduce(fn, a);\\n\\nconsole.log(\\n  reducePolymorphic(\\n    (a: number, b: string) => b.charCodeAt(0) + a,\\n    0,\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"Another example is reduce\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"105:110 file=./polymorphism.ts title=\\\"Monomorphic Reduce\\\"\",\n    \"105:110\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Monomorphic\",\n    \"Reduce\\\"\": true\n  }), \"interface Appendable<T> {\\n  append(a: Appendable<T>): Appendable<T>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  a: Type,\\n  b: Type\\n): Type => a.append(b) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(a: _String): _String {\\n    return new _String(`${this.value}${a.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(a: _Number): _Number {\\n    return new _Number(this.value + a.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <T, U>(\\n  fn: (a: T) => U,\\n  array: T[]\\n): U[] => [fn(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (a: number) => String.fromCharCode(a),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<T> {\\n  map<U>(f: (x: T) => U): Mappable<U>;\\n}\\n\\ninterface Reducable<T> {\\n  reduce<U>(f: (a: U, b: T) => U, a: U): U;\\n}\\n\\nclass _List<T>\\n  implements Appendable<_List<T>>, Mappable<T>, Reducable<T> {\\n  public value: T[];\\n\\n  constructor(value: T[]) {\\n    this.value = value;\\n  }\\n\\n  append(a: _List<T>): _List<T> {\\n    return new _List([...this.value, ...a.value]);\\n  }\\n\\n  map<U>(f: (x: T) => U) {\\n    return this.value.map(f);\\n  }\\n\\n  reduce<U>(f: (x: U, y: T) => U, a: U) {\\n    return this.value.reduce(f, a);\\n  }\\n}\\n\\nconst mapPolymorphic = <T, U>(\\n  fn: (a: T) => U,\\n  xs: Mappable<T>\\n): Mappable<U> => xs.map(fn);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (a: number) => String.fromCharCode(a),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <T, U>(\\n  reducer: (accumulator: U, current: T) => U,\\n  initialValue: U,\\n  array: T[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, current: string) =>\\n      current.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\nconst reducePolymorphic = <R extends Reducable<T>, T, U>(\\n  fn: (x: U, y: T) => U,\\n  a: U,\\n  xs: R\\n) => xs.reduce(fn, a);\\n\\nconsole.log(\\n  reducePolymorphic(\\n    (a: number, b: string) => b.charCodeAt(0) + a,\\n    0,\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"Because the types are fully specified, our function implementation has too much wiggle room.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"111:119 file=./polymorphism.ts title=\\\"Monomorphic Reduce\\\"\",\n    \"111:119\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Monomorphic\",\n    \"Reduce\\\"\": true\n  }), \"interface Appendable<T> {\\n  append(a: Appendable<T>): Appendable<T>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  a: Type,\\n  b: Type\\n): Type => a.append(b) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(a: _String): _String {\\n    return new _String(`${this.value}${a.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(a: _Number): _Number {\\n    return new _Number(this.value + a.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <T, U>(\\n  fn: (a: T) => U,\\n  array: T[]\\n): U[] => [fn(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (a: number) => String.fromCharCode(a),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<T> {\\n  map<U>(f: (x: T) => U): Mappable<U>;\\n}\\n\\ninterface Reducable<T> {\\n  reduce<U>(f: (a: U, b: T) => U, a: U): U;\\n}\\n\\nclass _List<T>\\n  implements Appendable<_List<T>>, Mappable<T>, Reducable<T> {\\n  public value: T[];\\n\\n  constructor(value: T[]) {\\n    this.value = value;\\n  }\\n\\n  append(a: _List<T>): _List<T> {\\n    return new _List([...this.value, ...a.value]);\\n  }\\n\\n  map<U>(f: (x: T) => U) {\\n    return this.value.map(f);\\n  }\\n\\n  reduce<U>(f: (x: U, y: T) => U, a: U) {\\n    return this.value.reduce(f, a);\\n  }\\n}\\n\\nconst mapPolymorphic = <T, U>(\\n  fn: (a: T) => U,\\n  xs: Mappable<T>\\n): Mappable<U> => xs.map(fn);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (a: number) => String.fromCharCode(a),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <T, U>(\\n  reducer: (accumulator: U, current: T) => U,\\n  initialValue: U,\\n  array: T[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, current: string) =>\\n      current.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\nconst reducePolymorphic = <R extends Reducable<T>, T, U>(\\n  fn: (x: U, y: T) => U,\\n  a: U,\\n  xs: R\\n) => xs.reduce(fn, a);\\n\\nconsole.log(\\n  reducePolymorphic(\\n    (a: number, b: string) => b.charCodeAt(0) + a,\\n    0,\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"We can create another interface to represent the ability to reduce, or aggregate, the contents of a container.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"67:69 file=./polymorphism.ts title=\\\"Reducable Interface\\\"\",\n    \"67:69\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Reducable\",\n    \"Interface\\\"\": true\n  }), \"interface Appendable<T> {\\n  append(a: Appendable<T>): Appendable<T>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  a: Type,\\n  b: Type\\n): Type => a.append(b) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(a: _String): _String {\\n    return new _String(`${this.value}${a.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(a: _Number): _Number {\\n    return new _Number(this.value + a.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <T, U>(\\n  fn: (a: T) => U,\\n  array: T[]\\n): U[] => [fn(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (a: number) => String.fromCharCode(a),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<T> {\\n  map<U>(f: (x: T) => U): Mappable<U>;\\n}\\n\\ninterface Reducable<T> {\\n  reduce<U>(f: (a: U, b: T) => U, a: U): U;\\n}\\n\\nclass _List<T>\\n  implements Appendable<_List<T>>, Mappable<T>, Reducable<T> {\\n  public value: T[];\\n\\n  constructor(value: T[]) {\\n    this.value = value;\\n  }\\n\\n  append(a: _List<T>): _List<T> {\\n    return new _List([...this.value, ...a.value]);\\n  }\\n\\n  map<U>(f: (x: T) => U) {\\n    return this.value.map(f);\\n  }\\n\\n  reduce<U>(f: (x: U, y: T) => U, a: U) {\\n    return this.value.reduce(f, a);\\n  }\\n}\\n\\nconst mapPolymorphic = <T, U>(\\n  fn: (a: T) => U,\\n  xs: Mappable<T>\\n): Mappable<U> => xs.map(fn);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (a: number) => String.fromCharCode(a),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <T, U>(\\n  reducer: (accumulator: U, current: T) => U,\\n  initialValue: U,\\n  array: T[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, current: string) =>\\n      current.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\nconst reducePolymorphic = <R extends Reducable<T>, T, U>(\\n  fn: (x: U, y: T) => U,\\n  a: U,\\n  xs: R\\n) => xs.reduce(fn, a);\\n\\nconsole.log(\\n  reducePolymorphic(\\n    (a: number, b: string) => b.charCodeAt(0) + a,\\n    0,\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"Our \", mdx(Code, {\n    mdxType: \"Code\"\n  }, \"_List\"), \" class implements \", mdx(Code, {\n    mdxType: \"Code\"\n  }, \"Reducable\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"71:90 file=./polymorphism.ts title=\\\"Implementing Reducable\\\"\",\n    \"71:90\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Implementing\",\n    \"Reducable\\\"\": true\n  }), \"interface Appendable<T> {\\n  append(a: Appendable<T>): Appendable<T>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  a: Type,\\n  b: Type\\n): Type => a.append(b) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(a: _String): _String {\\n    return new _String(`${this.value}${a.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(a: _Number): _Number {\\n    return new _Number(this.value + a.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <T, U>(\\n  fn: (a: T) => U,\\n  array: T[]\\n): U[] => [fn(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (a: number) => String.fromCharCode(a),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<T> {\\n  map<U>(f: (x: T) => U): Mappable<U>;\\n}\\n\\ninterface Reducable<T> {\\n  reduce<U>(f: (a: U, b: T) => U, a: U): U;\\n}\\n\\nclass _List<T>\\n  implements Appendable<_List<T>>, Mappable<T>, Reducable<T> {\\n  public value: T[];\\n\\n  constructor(value: T[]) {\\n    this.value = value;\\n  }\\n\\n  append(a: _List<T>): _List<T> {\\n    return new _List([...this.value, ...a.value]);\\n  }\\n\\n  map<U>(f: (x: T) => U) {\\n    return this.value.map(f);\\n  }\\n\\n  reduce<U>(f: (x: U, y: T) => U, a: U) {\\n    return this.value.reduce(f, a);\\n  }\\n}\\n\\nconst mapPolymorphic = <T, U>(\\n  fn: (a: T) => U,\\n  xs: Mappable<T>\\n): Mappable<U> => xs.map(fn);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (a: number) => String.fromCharCode(a),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <T, U>(\\n  reducer: (accumulator: U, current: T) => U,\\n  initialValue: U,\\n  array: T[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, current: string) =>\\n      current.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\nconst reducePolymorphic = <R extends Reducable<T>, T, U>(\\n  fn: (x: U, y: T) => U,\\n  a: U,\\n  xs: R\\n) => xs.reduce(fn, a);\\n\\nconsole.log(\\n  reducePolymorphic(\\n    (a: number, b: string) => b.charCodeAt(0) + a,\\n    0,\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"We can define our polymorphic \", mdx(Code, {\n    mdxType: \"Code\"\n  }, \"reduce\"), \" like so\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"120:125 file=./polymorphism.ts title=\\\"Polymorphic Reduce\\\"\",\n    \"120:125\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Polymorphic\",\n    \"Reduce\\\"\": true\n  }), \"interface Appendable<T> {\\n  append(a: Appendable<T>): Appendable<T>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  a: Type,\\n  b: Type\\n): Type => a.append(b) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(a: _String): _String {\\n    return new _String(`${this.value}${a.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(a: _Number): _Number {\\n    return new _Number(this.value + a.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <T, U>(\\n  fn: (a: T) => U,\\n  array: T[]\\n): U[] => [fn(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (a: number) => String.fromCharCode(a),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<T> {\\n  map<U>(f: (x: T) => U): Mappable<U>;\\n}\\n\\ninterface Reducable<T> {\\n  reduce<U>(f: (a: U, b: T) => U, a: U): U;\\n}\\n\\nclass _List<T>\\n  implements Appendable<_List<T>>, Mappable<T>, Reducable<T> {\\n  public value: T[];\\n\\n  constructor(value: T[]) {\\n    this.value = value;\\n  }\\n\\n  append(a: _List<T>): _List<T> {\\n    return new _List([...this.value, ...a.value]);\\n  }\\n\\n  map<U>(f: (x: T) => U) {\\n    return this.value.map(f);\\n  }\\n\\n  reduce<U>(f: (x: U, y: T) => U, a: U) {\\n    return this.value.reduce(f, a);\\n  }\\n}\\n\\nconst mapPolymorphic = <T, U>(\\n  fn: (a: T) => U,\\n  xs: Mappable<T>\\n): Mappable<U> => xs.map(fn);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (a: number) => String.fromCharCode(a),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <T, U>(\\n  reducer: (accumulator: U, current: T) => U,\\n  initialValue: U,\\n  array: T[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, current: string) =>\\n      current.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\nconst reducePolymorphic = <R extends Reducable<T>, T, U>(\\n  fn: (x: U, y: T) => U,\\n  a: U,\\n  xs: R\\n) => xs.reduce(fn, a);\\n\\nconsole.log(\\n  reducePolymorphic(\\n    (a: number, b: string) => b.charCodeAt(0) + a,\\n    0,\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"We can be more confident this function does what it says.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"127:135 file=./polymorphism.ts title=\\\"Polymorphic Reduce\\\"\",\n    \"127:135\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Polymorphic\",\n    \"Reduce\\\"\": true\n  }), \"interface Appendable<T> {\\n  append(a: Appendable<T>): Appendable<T>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  a: Type,\\n  b: Type\\n): Type => a.append(b) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(a: _String): _String {\\n    return new _String(`${this.value}${a.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(a: _Number): _Number {\\n    return new _Number(this.value + a.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <T, U>(\\n  fn: (a: T) => U,\\n  array: T[]\\n): U[] => [fn(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (a: number) => String.fromCharCode(a),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<T> {\\n  map<U>(f: (x: T) => U): Mappable<U>;\\n}\\n\\ninterface Reducable<T> {\\n  reduce<U>(f: (a: U, b: T) => U, a: U): U;\\n}\\n\\nclass _List<T>\\n  implements Appendable<_List<T>>, Mappable<T>, Reducable<T> {\\n  public value: T[];\\n\\n  constructor(value: T[]) {\\n    this.value = value;\\n  }\\n\\n  append(a: _List<T>): _List<T> {\\n    return new _List([...this.value, ...a.value]);\\n  }\\n\\n  map<U>(f: (x: T) => U) {\\n    return this.value.map(f);\\n  }\\n\\n  reduce<U>(f: (x: U, y: T) => U, a: U) {\\n    return this.value.reduce(f, a);\\n  }\\n}\\n\\nconst mapPolymorphic = <T, U>(\\n  fn: (a: T) => U,\\n  xs: Mappable<T>\\n): Mappable<U> => xs.map(fn);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (a: number) => String.fromCharCode(a),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <T, U>(\\n  reducer: (accumulator: U, current: T) => U,\\n  initialValue: U,\\n  array: T[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, current: string) =>\\n      current.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\nconst reducePolymorphic = <R extends Reducable<T>, T, U>(\\n  fn: (x: U, y: T) => U,\\n  a: U,\\n  xs: R\\n) => xs.reduce(fn, a);\\n\\nconsole.log(\\n  reducePolymorphic(\\n    (a: number, b: string) => b.charCodeAt(0) + a,\\n    0,\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\")))), mdx(\"hr\", null), mdx(\"h1\", null, \"Why though?\"), mdx(\"ul\", null, mdx(Appear, {\n    mdxType: \"Appear\"\n  }, mdx(\"li\", null, \"Priotizes correctness\"), mdx(\"li\", null, \"Enables composition of logic structures\"), mdx(\"li\", null, \"Reduces duplication\"))), mdx(\"hr\", null), mdx(\"h1\", null, \"Limitations of TypeScript\"), mdx(\"ul\", null, mdx(Appear, {\n    mdxType: \"Appear\"\n  }, mdx(\"li\", null, \"No Typeclasses\"), mdx(\"li\", null, \"More verbose\"), mdx(\"li\", null, \"Requires use of \", mdx(Code, {\n    mdxType: \"Code\"\n  }, \"this\"), \" in classes\"))), mdx(\"hr\", null), mdx(\"h1\", null, \"Thank you!\"), mdx(\"p\", null, \"Questions?\"), mdx(\"h3\", null, \"Further Reading\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    href: \"http://degoes.net/articles/insufficiently-polymorphic\"\n  }, \"Insufficiently Polymorphic\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    href: \"https://soundcloud.com/lambda-cast/9-polymorphism-and-abstraction\"\n  }, \"Polymorphism and Abstraction\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    href: \"https://www.youtube.com/watch?v=BHjIl81HgfE\"\n  }, \"Add a Type Parameter\"))), mdx(\"hr\", null));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"97c449b9-8404-5627-8399-2a245f6c4575","slug":"/polymorphism-in-typescript","title":"Polymorphism in TypeScript"}}}