{"componentChunkName":"component---node-modules-gatsby-theme-mdx-deck-src-templates-deck-js","path":"/","matchPath":"/*","result":{"data":{"deck":{"id":"97c449b9-8404-5627-8399-2a245f6c4575","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar theme = nightOwl;\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  theme: theme,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Polymorphism in TypeScript\"), mdx(\"span\", null, mdx(\"a\", {\n    href: \"https://github.com/sliptype\"\n  }, \"@sliptype\"), mdx(\"span\", {\n    style: {\n      marginLeft: '1rem',\n      marginRight: '1rem'\n    }\n  }, \"|\"), mdx(\"a\", {\n    href: \"https://codesandbox.io/s/polymorphism-in-typescript-pwqx3\"\n  }, \"get the code\")), mdx(\"hr\", null), mdx(Definition, {\n    syllables: ['Type', 'Script'],\n    type: 'noun',\n    definition: 'a strict syntactical superset of JavaScript whichs adds optional static typing to the language.',\n    mdxType: \"Definition\"\n  }), mdx(\"hr\", null), mdx(Definition, {\n    syllables: ['pol', 'y', 'morph', 'is', 'm'],\n    type: 'noun',\n    definition: 'the condition of occurring in several different forms.',\n    mdxType: \"Definition\"\n  }), mdx(\"hr\", null), mdx(Definition, {\n    syllables: ['pol', 'y', 'morph', 'is', 'm'],\n    type: 'noun',\n    definition: 'the provision of a single interface to entities of different types or the use of a single symbol to represent multiple different types.',\n    mdxType: \"Definition\"\n  }), mdx(\"hr\", null), mdx(CodeSurfer, {\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"title=\\\"Type Signatures\\\" subtitle=\\\"Define the inputs and outputs for a function\\\"\",\n    \"title\": \"\\\"Type\",\n    \"Signatures\\\"\": true,\n    \"subtitle\": \"\\\"Define\",\n    \"the\": true,\n    \"inputs\": true,\n    \"and\": true,\n    \"outputs\": true,\n    \"for\": true,\n    \"a\": true,\n    \"function\\\"\": true\n  }), \"  // Return the string that is passed in\\n  const identity = (myString: string): string\\n    => myString\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"title=\\\"Monomorphic Functions\\\" subtitle=\\\"Have a large implementation space\\\"\",\n    \"title\": \"\\\"Monomorphic\",\n    \"Functions\\\"\": true,\n    \"subtitle\": \"\\\"Have\",\n    \"a\": true,\n    \"large\": true,\n    \"implementation\": true,\n    \"space\\\"\": true\n  }), \"  // Return the string that is passed in\\n  const identity = (myString: string): string\\n    => 'Hello, Mr. Bug'\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"title=\\\"Monomorphic Functions\\\" subtitle=\\\"Duplicate logic for multiple data types\\\"\",\n    \"title\": \"\\\"Monomorphic\",\n    \"Functions\\\"\": true,\n    \"subtitle\": \"\\\"Duplicate\",\n    \"logic\": true,\n    \"for\": true,\n    \"multiple\": true,\n    \"data\": true,\n    \"types\\\"\": true\n  }), \"  // Return the number that is passed in\\n  const identity = (myNumber: number): number\\n    => myNumber\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"title=\\\"Type Parameters\\\" subtitle=\\\"Allow for a more generic implementation of the function\\\"\",\n    \"title\": \"\\\"Type\",\n    \"Parameters\\\"\": true,\n    \"subtitle\": \"\\\"Allow\",\n    \"for\": true,\n    \"a\": true,\n    \"more\": true,\n    \"generic\": true,\n    \"implementation\": true,\n    \"of\": true,\n    \"the\": true,\n    \"function\\\"\": true\n  }), \"  // Return the value of type MyType that is passed in\\n  const identity = <MyType>(x: MyType): MyType\\n    => x\\n\"))), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    themes: [github],\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"1:4 title=\\\"Monomorphic Functions\\\"\",\n    \"1:4\": true,\n    \"title\": \"\\\"Monomorphic\",\n    \"Functions\\\"\": true\n  }), \"const appendString = (\\n  beginning: string,\\n  end: string\\n): string => beginning + \\\"Mr. Bug, \\\" + end;\\n\\nconsole.log(appendString(\\\"hello \\\", \\\"how are you?\\\"));\\n\")), mdx(Text, {\n    mdxType: \"Text\"\n  }, \"When types are concrete, we often have to break the abstraction and look inside the function to know that it's name is not lying to us.\")), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"6:7 title=\\\"Monomorphic Functions\\\"\",\n    \"6:7\": true,\n    \"title\": \"\\\"Monomorphic\",\n    \"Functions\\\"\": true\n  }), \"const appendString = (\\n  beginning: string,\\n  end: string\\n): string => beginning + \\\"Mr. Bug, \\\" + end;\\n\\nconsole.log(appendString(\\\"hello \\\", \\\"how are you?\\\"));\\n// \\\"hello Mr. Bug, how are you?\\\"\\n\")), mdx(Text, {\n    mdxType: \"Text\"\n  }, \"Knowing more about the types in our signature means we know less about the implementation of our function.\"))), mdx(\"hr\", null), mdx(Text, {\n    mdxType: \"Text\"\n  }, mdx(\"p\", null, \"  Require the least powerful interface you need to implement a function.\")), mdx(\"hr\", null), mdx(CodeSurferColumns, {\n    themes: [extraTheme, extraTheme],\n    mdxType: \"CodeSurferColumns\"\n  }, mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"All we really need to know about the argument for \", mdx(Code, {\n    mdxType: \"Code\"\n  }, \"appendString\"), \" is that it is appendable.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"1:5 file=./polymorphism.ts title=\\\"Appendable Interface\\\"\",\n    \"1:5\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Appendable\",\n    \"Interface\\\"\": true\n  }), \"interface Appendable<ElementType> {\\n  append(\\n    end: Appendable<ElementType>\\n  ): Appendable<ElementType>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  beginning: Type,\\n  end: Type\\n): Type => beginning.append(end) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(end: _String): _String {\\n    return new _String(`${this.value}${end.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(end: _Number): _Number {\\n    return new _Number(this.value + end.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <ElementType, ResultType>(\\n\\n  // A mapping function\\n  mapper: (currentElement: ElementType) => ResultType,\\n\\n  // An array containing data\\n  array: ElementType[]\\n\\n): ResultType[] => [mapper(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (\\n      currentElement: number\\n    ) => String.fromCharCode(currentElement),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<ElementType> {\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (\\n      currentElement: ElementType\\n    ) => ResultType\\n\\n  ): Mappable<ResultType>;\\n}\\n\\nclass _List<ElementType> implements Mappable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (currentElement: ElementType) => ResultType\\n  ) {\\n    return this.value.map(mapper);\\n  }\\n\\n}\\n\\nconst mapPolymorphic = <ElementType, ResultType>(\\n  mapper: (currentElement: ElementType) => ResultType,\\n  data: Mappable<ElementType>\\n): Mappable<ResultType> => data.map(mapper);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (currentElement: number) => String.fromCharCode(currentElement),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (\\n    accumulator: ResultType,\\n    currentElement: ElementType\\n  ) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The array containing data\\n  array: ElementType[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, currentElement: string) =>\\n      currentElement.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\ninterface Reducable<ElementType> {\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n  ): ResultType;\\n}\\n\\nclass _List<ElementType> implements Reducable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n\\n  ) {\\n    return this.value.reduce(reducer, initialValue);\\n  }\\n}\\n\\nconst reducePolymorphic = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (x: ResultType, y: ElementType) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The container containing data\\n  data: Reducable<ElementType>\\n) => data.reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reducePolymorphic(\\n\\n    // A reducer function\\n    (\\n      accumulator: number,\\n      currentElement: string\\n    ) => currentElement.charCodeAt(0) + accumulator,\\n\\n    // The initial value\\n    0,\\n\\n    // The container containing data\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"This function only has four possible implementations!\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"7:10 file=./polymorphism.ts title=\\\"Polymorphic Append\\\"\",\n    \"7:10\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Polymorphic\",\n    \"Append\\\"\": true\n  }), \"interface Appendable<ElementType> {\\n  append(\\n    end: Appendable<ElementType>\\n  ): Appendable<ElementType>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  beginning: Type,\\n  end: Type\\n): Type => beginning.append(end) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(end: _String): _String {\\n    return new _String(`${this.value}${end.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(end: _Number): _Number {\\n    return new _Number(this.value + end.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <ElementType, ResultType>(\\n\\n  // A mapping function\\n  mapper: (currentElement: ElementType) => ResultType,\\n\\n  // An array containing data\\n  array: ElementType[]\\n\\n): ResultType[] => [mapper(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (\\n      currentElement: number\\n    ) => String.fromCharCode(currentElement),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<ElementType> {\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (\\n      currentElement: ElementType\\n    ) => ResultType\\n\\n  ): Mappable<ResultType>;\\n}\\n\\nclass _List<ElementType> implements Mappable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (currentElement: ElementType) => ResultType\\n  ) {\\n    return this.value.map(mapper);\\n  }\\n\\n}\\n\\nconst mapPolymorphic = <ElementType, ResultType>(\\n  mapper: (currentElement: ElementType) => ResultType,\\n  data: Mappable<ElementType>\\n): Mappable<ResultType> => data.map(mapper);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (currentElement: number) => String.fromCharCode(currentElement),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (\\n    accumulator: ResultType,\\n    currentElement: ElementType\\n  ) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The array containing data\\n  array: ElementType[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, currentElement: string) =>\\n      currentElement.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\ninterface Reducable<ElementType> {\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n  ): ResultType;\\n}\\n\\nclass _List<ElementType> implements Reducable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n\\n  ) {\\n    return this.value.reduce(reducer, initialValue);\\n  }\\n}\\n\\nconst reducePolymorphic = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (x: ResultType, y: ElementType) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The container containing data\\n  data: Reducable<ElementType>\\n) => data.reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reducePolymorphic(\\n\\n    // A reducer function\\n    (\\n      accumulator: number,\\n      currentElement: string\\n    ) => currentElement.charCodeAt(0) + accumulator,\\n\\n    // The initial value\\n    0,\\n\\n    // The container containing data\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"TypeScript enables us to implement this interface for our own \", mdx(Code, {\n    mdxType: \"Code\"\n  }, \"_String\"), \" type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"12:22 file=./polymorphism.ts title=\\\"Implementing Appendable\\\"\",\n    \"12:22\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Implementing\",\n    \"Appendable\\\"\": true\n  }), \"interface Appendable<ElementType> {\\n  append(\\n    end: Appendable<ElementType>\\n  ): Appendable<ElementType>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  beginning: Type,\\n  end: Type\\n): Type => beginning.append(end) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(end: _String): _String {\\n    return new _String(`${this.value}${end.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(end: _Number): _Number {\\n    return new _Number(this.value + end.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <ElementType, ResultType>(\\n\\n  // A mapping function\\n  mapper: (currentElement: ElementType) => ResultType,\\n\\n  // An array containing data\\n  array: ElementType[]\\n\\n): ResultType[] => [mapper(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (\\n      currentElement: number\\n    ) => String.fromCharCode(currentElement),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<ElementType> {\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (\\n      currentElement: ElementType\\n    ) => ResultType\\n\\n  ): Mappable<ResultType>;\\n}\\n\\nclass _List<ElementType> implements Mappable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (currentElement: ElementType) => ResultType\\n  ) {\\n    return this.value.map(mapper);\\n  }\\n\\n}\\n\\nconst mapPolymorphic = <ElementType, ResultType>(\\n  mapper: (currentElement: ElementType) => ResultType,\\n  data: Mappable<ElementType>\\n): Mappable<ResultType> => data.map(mapper);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (currentElement: number) => String.fromCharCode(currentElement),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (\\n    accumulator: ResultType,\\n    currentElement: ElementType\\n  ) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The array containing data\\n  array: ElementType[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, currentElement: string) =>\\n      currentElement.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\ninterface Reducable<ElementType> {\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n  ): ResultType;\\n}\\n\\nclass _List<ElementType> implements Reducable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n\\n  ) {\\n    return this.value.reduce(reducer, initialValue);\\n  }\\n}\\n\\nconst reducePolymorphic = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (x: ResultType, y: ElementType) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The container containing data\\n  data: Reducable<ElementType>\\n) => data.reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reducePolymorphic(\\n\\n    // A reducer function\\n    (\\n      accumulator: number,\\n      currentElement: string\\n    ) => currentElement.charCodeAt(0) + accumulator,\\n\\n    // The initial value\\n    0,\\n\\n    // The container containing data\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"This results in a function that has more utility and fewer possible implementations.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"24:30 file=./polymorphism.ts title=\\\"Polymorphic Append\\\"\",\n    \"24:30\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Polymorphic\",\n    \"Append\\\"\": true\n  }), \"interface Appendable<ElementType> {\\n  append(\\n    end: Appendable<ElementType>\\n  ): Appendable<ElementType>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  beginning: Type,\\n  end: Type\\n): Type => beginning.append(end) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(end: _String): _String {\\n    return new _String(`${this.value}${end.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(end: _Number): _Number {\\n    return new _Number(this.value + end.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <ElementType, ResultType>(\\n\\n  // A mapping function\\n  mapper: (currentElement: ElementType) => ResultType,\\n\\n  // An array containing data\\n  array: ElementType[]\\n\\n): ResultType[] => [mapper(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (\\n      currentElement: number\\n    ) => String.fromCharCode(currentElement),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<ElementType> {\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (\\n      currentElement: ElementType\\n    ) => ResultType\\n\\n  ): Mappable<ResultType>;\\n}\\n\\nclass _List<ElementType> implements Mappable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (currentElement: ElementType) => ResultType\\n  ) {\\n    return this.value.map(mapper);\\n  }\\n\\n}\\n\\nconst mapPolymorphic = <ElementType, ResultType>(\\n  mapper: (currentElement: ElementType) => ResultType,\\n  data: Mappable<ElementType>\\n): Mappable<ResultType> => data.map(mapper);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (currentElement: number) => String.fromCharCode(currentElement),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (\\n    accumulator: ResultType,\\n    currentElement: ElementType\\n  ) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The array containing data\\n  array: ElementType[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, currentElement: string) =>\\n      currentElement.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\ninterface Reducable<ElementType> {\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n  ): ResultType;\\n}\\n\\nclass _List<ElementType> implements Reducable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n\\n  ) {\\n    return this.value.reduce(reducer, initialValue);\\n  }\\n}\\n\\nconst reducePolymorphic = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (x: ResultType, y: ElementType) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The container containing data\\n  data: Reducable<ElementType>\\n) => data.reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reducePolymorphic(\\n\\n    // A reducer function\\n    (\\n      accumulator: number,\\n      currentElement: string\\n    ) => currentElement.charCodeAt(0) + accumulator,\\n\\n    // The initial value\\n    0,\\n\\n    // The container containing data\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"We can give any type of data the \\\"appendability\\\" property by implementing the interface.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"32:42 file=./polymorphism.ts title=\\\"Implementing Appendable\\\"\",\n    \"32:42\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Implementing\",\n    \"Appendable\\\"\": true\n  }), \"interface Appendable<ElementType> {\\n  append(\\n    end: Appendable<ElementType>\\n  ): Appendable<ElementType>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  beginning: Type,\\n  end: Type\\n): Type => beginning.append(end) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(end: _String): _String {\\n    return new _String(`${this.value}${end.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(end: _Number): _Number {\\n    return new _Number(this.value + end.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <ElementType, ResultType>(\\n\\n  // A mapping function\\n  mapper: (currentElement: ElementType) => ResultType,\\n\\n  // An array containing data\\n  array: ElementType[]\\n\\n): ResultType[] => [mapper(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (\\n      currentElement: number\\n    ) => String.fromCharCode(currentElement),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<ElementType> {\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (\\n      currentElement: ElementType\\n    ) => ResultType\\n\\n  ): Mappable<ResultType>;\\n}\\n\\nclass _List<ElementType> implements Mappable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (currentElement: ElementType) => ResultType\\n  ) {\\n    return this.value.map(mapper);\\n  }\\n\\n}\\n\\nconst mapPolymorphic = <ElementType, ResultType>(\\n  mapper: (currentElement: ElementType) => ResultType,\\n  data: Mappable<ElementType>\\n): Mappable<ResultType> => data.map(mapper);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (currentElement: number) => String.fromCharCode(currentElement),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (\\n    accumulator: ResultType,\\n    currentElement: ElementType\\n  ) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The array containing data\\n  array: ElementType[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, currentElement: string) =>\\n      currentElement.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\ninterface Reducable<ElementType> {\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n  ): ResultType;\\n}\\n\\nclass _List<ElementType> implements Reducable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n\\n  ) {\\n    return this.value.reduce(reducer, initialValue);\\n  }\\n}\\n\\nconst reducePolymorphic = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (x: ResultType, y: ElementType) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The container containing data\\n  data: Reducable<ElementType>\\n) => data.reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reducePolymorphic(\\n\\n    // A reducer function\\n    (\\n      accumulator: number,\\n      currentElement: string\\n    ) => currentElement.charCodeAt(0) + accumulator,\\n\\n    // The initial value\\n    0,\\n\\n    // The container containing data\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"This allows reuse of our function.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"43:50 file=./polymorphism.ts title=\\\"Polymorphic Append\\\"\",\n    \"43:50\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Polymorphic\",\n    \"Append\\\"\": true\n  }), \"interface Appendable<ElementType> {\\n  append(\\n    end: Appendable<ElementType>\\n  ): Appendable<ElementType>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  beginning: Type,\\n  end: Type\\n): Type => beginning.append(end) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(end: _String): _String {\\n    return new _String(`${this.value}${end.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(end: _Number): _Number {\\n    return new _Number(this.value + end.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <ElementType, ResultType>(\\n\\n  // A mapping function\\n  mapper: (currentElement: ElementType) => ResultType,\\n\\n  // An array containing data\\n  array: ElementType[]\\n\\n): ResultType[] => [mapper(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (\\n      currentElement: number\\n    ) => String.fromCharCode(currentElement),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<ElementType> {\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (\\n      currentElement: ElementType\\n    ) => ResultType\\n\\n  ): Mappable<ResultType>;\\n}\\n\\nclass _List<ElementType> implements Mappable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (currentElement: ElementType) => ResultType\\n  ) {\\n    return this.value.map(mapper);\\n  }\\n\\n}\\n\\nconst mapPolymorphic = <ElementType, ResultType>(\\n  mapper: (currentElement: ElementType) => ResultType,\\n  data: Mappable<ElementType>\\n): Mappable<ResultType> => data.map(mapper);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (currentElement: number) => String.fromCharCode(currentElement),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (\\n    accumulator: ResultType,\\n    currentElement: ElementType\\n  ) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The array containing data\\n  array: ElementType[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, currentElement: string) =>\\n      currentElement.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\ninterface Reducable<ElementType> {\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n  ): ResultType;\\n}\\n\\nclass _List<ElementType> implements Reducable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n\\n  ) {\\n    return this.value.reduce(reducer, initialValue);\\n  }\\n}\\n\\nconst reducePolymorphic = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (x: ResultType, y: ElementType) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The container containing data\\n  data: Reducable<ElementType>\\n) => data.reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reducePolymorphic(\\n\\n    // A reducer function\\n    (\\n      accumulator: number,\\n      currentElement: string\\n    ) => currentElement.charCodeAt(0) + accumulator,\\n\\n    // The initial value\\n    0,\\n\\n    // The container containing data\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"Fully specifying container types, like arrays, also presents problems.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"52:70 file=./polymorphism.ts title=\\\"Monomorphic Map\\\"\",\n    \"52:70\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Monomorphic\",\n    \"Map\\\"\": true\n  }), \"interface Appendable<ElementType> {\\n  append(\\n    end: Appendable<ElementType>\\n  ): Appendable<ElementType>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  beginning: Type,\\n  end: Type\\n): Type => beginning.append(end) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(end: _String): _String {\\n    return new _String(`${this.value}${end.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(end: _Number): _Number {\\n    return new _Number(this.value + end.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <ElementType, ResultType>(\\n\\n  // A mapping function\\n  mapper: (currentElement: ElementType) => ResultType,\\n\\n  // An array containing data\\n  array: ElementType[]\\n\\n): ResultType[] => [mapper(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (\\n      currentElement: number\\n    ) => String.fromCharCode(currentElement),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<ElementType> {\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (\\n      currentElement: ElementType\\n    ) => ResultType\\n\\n  ): Mappable<ResultType>;\\n}\\n\\nclass _List<ElementType> implements Mappable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (currentElement: ElementType) => ResultType\\n  ) {\\n    return this.value.map(mapper);\\n  }\\n\\n}\\n\\nconst mapPolymorphic = <ElementType, ResultType>(\\n  mapper: (currentElement: ElementType) => ResultType,\\n  data: Mappable<ElementType>\\n): Mappable<ResultType> => data.map(mapper);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (currentElement: number) => String.fromCharCode(currentElement),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (\\n    accumulator: ResultType,\\n    currentElement: ElementType\\n  ) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The array containing data\\n  array: ElementType[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, currentElement: string) =>\\n      currentElement.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\ninterface Reducable<ElementType> {\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n  ): ResultType;\\n}\\n\\nclass _List<ElementType> implements Reducable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n\\n  ) {\\n    return this.value.reduce(reducer, initialValue);\\n  }\\n}\\n\\nconst reducePolymorphic = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (x: ResultType, y: ElementType) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The container containing data\\n  data: Reducable<ElementType>\\n) => data.reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reducePolymorphic(\\n\\n    // A reducer function\\n    (\\n      accumulator: number,\\n      currentElement: string\\n    ) => currentElement.charCodeAt(0) + accumulator,\\n\\n    // The initial value\\n    0,\\n\\n    // The container containing data\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"An array is one of many types that can be mapped.\", mdx(\"div\", {\n    style: {\n      marginTop: '2rem',\n      textAlign: 'left'\n    }\n  }, \"Others include:\", mdx(\"ul\", null, mdx(\"li\", null, \"Object\"), mdx(\"li\", null, \"Tree\"), mdx(\"li\", null, \"Tuple\")))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"72:81 file=./polymorphism.ts title=\\\"Mappable Interface\\\"\",\n    \"72:81\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Mappable\",\n    \"Interface\\\"\": true\n  }), \"interface Appendable<ElementType> {\\n  append(\\n    end: Appendable<ElementType>\\n  ): Appendable<ElementType>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  beginning: Type,\\n  end: Type\\n): Type => beginning.append(end) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(end: _String): _String {\\n    return new _String(`${this.value}${end.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(end: _Number): _Number {\\n    return new _Number(this.value + end.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <ElementType, ResultType>(\\n\\n  // A mapping function\\n  mapper: (currentElement: ElementType) => ResultType,\\n\\n  // An array containing data\\n  array: ElementType[]\\n\\n): ResultType[] => [mapper(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (\\n      currentElement: number\\n    ) => String.fromCharCode(currentElement),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<ElementType> {\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (\\n      currentElement: ElementType\\n    ) => ResultType\\n\\n  ): Mappable<ResultType>;\\n}\\n\\nclass _List<ElementType> implements Mappable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (currentElement: ElementType) => ResultType\\n  ) {\\n    return this.value.map(mapper);\\n  }\\n\\n}\\n\\nconst mapPolymorphic = <ElementType, ResultType>(\\n  mapper: (currentElement: ElementType) => ResultType,\\n  data: Mappable<ElementType>\\n): Mappable<ResultType> => data.map(mapper);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (currentElement: number) => String.fromCharCode(currentElement),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (\\n    accumulator: ResultType,\\n    currentElement: ElementType\\n  ) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The array containing data\\n  array: ElementType[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, currentElement: string) =>\\n      currentElement.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\ninterface Reducable<ElementType> {\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n  ): ResultType;\\n}\\n\\nclass _List<ElementType> implements Reducable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n\\n  ) {\\n    return this.value.reduce(reducer, initialValue);\\n  }\\n}\\n\\nconst reducePolymorphic = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (x: ResultType, y: ElementType) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The container containing data\\n  data: Reducable<ElementType>\\n) => data.reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reducePolymorphic(\\n\\n    // A reducer function\\n    (\\n      accumulator: number,\\n      currentElement: string\\n    ) => currentElement.charCodeAt(0) + accumulator,\\n\\n    // The initial value\\n    0,\\n\\n    // The container containing data\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"To make use of this, we can create a \", mdx(Code, {\n    mdxType: \"Code\"\n  }, \"_List\"), \" class that implements \", mdx(Code, {\n    mdxType: \"Code\"\n  }, \"Mappable\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"83:100 file=./polymorphism.ts title=\\\"Implementing Mappable\\\"\",\n    \"83:100\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Implementing\",\n    \"Mappable\\\"\": true\n  }), \"interface Appendable<ElementType> {\\n  append(\\n    end: Appendable<ElementType>\\n  ): Appendable<ElementType>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  beginning: Type,\\n  end: Type\\n): Type => beginning.append(end) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(end: _String): _String {\\n    return new _String(`${this.value}${end.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(end: _Number): _Number {\\n    return new _Number(this.value + end.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <ElementType, ResultType>(\\n\\n  // A mapping function\\n  mapper: (currentElement: ElementType) => ResultType,\\n\\n  // An array containing data\\n  array: ElementType[]\\n\\n): ResultType[] => [mapper(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (\\n      currentElement: number\\n    ) => String.fromCharCode(currentElement),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<ElementType> {\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (\\n      currentElement: ElementType\\n    ) => ResultType\\n\\n  ): Mappable<ResultType>;\\n}\\n\\nclass _List<ElementType> implements Mappable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (currentElement: ElementType) => ResultType\\n  ) {\\n    return this.value.map(mapper);\\n  }\\n\\n}\\n\\nconst mapPolymorphic = <ElementType, ResultType>(\\n  mapper: (currentElement: ElementType) => ResultType,\\n  data: Mappable<ElementType>\\n): Mappable<ResultType> => data.map(mapper);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (currentElement: number) => String.fromCharCode(currentElement),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (\\n    accumulator: ResultType,\\n    currentElement: ElementType\\n  ) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The array containing data\\n  array: ElementType[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, currentElement: string) =>\\n      currentElement.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\ninterface Reducable<ElementType> {\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n  ): ResultType;\\n}\\n\\nclass _List<ElementType> implements Reducable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n\\n  ) {\\n    return this.value.reduce(reducer, initialValue);\\n  }\\n}\\n\\nconst reducePolymorphic = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (x: ResultType, y: ElementType) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The container containing data\\n  data: Reducable<ElementType>\\n) => data.reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reducePolymorphic(\\n\\n    // A reducer function\\n    (\\n      accumulator: number,\\n      currentElement: string\\n    ) => currentElement.charCodeAt(0) + accumulator,\\n\\n    // The initial value\\n    0,\\n\\n    // The container containing data\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"This function only has one possible implementation!\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"101:105 file=./polymorphism.ts title=\\\"Polymorphic Map\\\"\",\n    \"101:105\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Polymorphic\",\n    \"Map\\\"\": true\n  }), \"interface Appendable<ElementType> {\\n  append(\\n    end: Appendable<ElementType>\\n  ): Appendable<ElementType>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  beginning: Type,\\n  end: Type\\n): Type => beginning.append(end) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(end: _String): _String {\\n    return new _String(`${this.value}${end.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(end: _Number): _Number {\\n    return new _Number(this.value + end.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <ElementType, ResultType>(\\n\\n  // A mapping function\\n  mapper: (currentElement: ElementType) => ResultType,\\n\\n  // An array containing data\\n  array: ElementType[]\\n\\n): ResultType[] => [mapper(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (\\n      currentElement: number\\n    ) => String.fromCharCode(currentElement),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<ElementType> {\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (\\n      currentElement: ElementType\\n    ) => ResultType\\n\\n  ): Mappable<ResultType>;\\n}\\n\\nclass _List<ElementType> implements Mappable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (currentElement: ElementType) => ResultType\\n  ) {\\n    return this.value.map(mapper);\\n  }\\n\\n}\\n\\nconst mapPolymorphic = <ElementType, ResultType>(\\n  mapper: (currentElement: ElementType) => ResultType,\\n  data: Mappable<ElementType>\\n): Mappable<ResultType> => data.map(mapper);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (currentElement: number) => String.fromCharCode(currentElement),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (\\n    accumulator: ResultType,\\n    currentElement: ElementType\\n  ) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The array containing data\\n  array: ElementType[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, currentElement: string) =>\\n      currentElement.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\ninterface Reducable<ElementType> {\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n  ): ResultType;\\n}\\n\\nclass _List<ElementType> implements Reducable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n\\n  ) {\\n    return this.value.reduce(reducer, initialValue);\\n  }\\n}\\n\\nconst reducePolymorphic = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (x: ResultType, y: ElementType) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The container containing data\\n  data: Reducable<ElementType>\\n) => data.reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reducePolymorphic(\\n\\n    // A reducer function\\n    (\\n      accumulator: number,\\n      currentElement: string\\n    ) => currentElement.charCodeAt(0) + accumulator,\\n\\n    // The initial value\\n    0,\\n\\n    // The container containing data\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"The implementation space is reduced from infinity to 1.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"106:113 file=./polymorphism.ts title=\\\"Polymorphic Map\\\"\",\n    \"106:113\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Polymorphic\",\n    \"Map\\\"\": true\n  }), \"interface Appendable<ElementType> {\\n  append(\\n    end: Appendable<ElementType>\\n  ): Appendable<ElementType>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  beginning: Type,\\n  end: Type\\n): Type => beginning.append(end) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(end: _String): _String {\\n    return new _String(`${this.value}${end.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(end: _Number): _Number {\\n    return new _Number(this.value + end.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <ElementType, ResultType>(\\n\\n  // A mapping function\\n  mapper: (currentElement: ElementType) => ResultType,\\n\\n  // An array containing data\\n  array: ElementType[]\\n\\n): ResultType[] => [mapper(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (\\n      currentElement: number\\n    ) => String.fromCharCode(currentElement),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<ElementType> {\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (\\n      currentElement: ElementType\\n    ) => ResultType\\n\\n  ): Mappable<ResultType>;\\n}\\n\\nclass _List<ElementType> implements Mappable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (currentElement: ElementType) => ResultType\\n  ) {\\n    return this.value.map(mapper);\\n  }\\n\\n}\\n\\nconst mapPolymorphic = <ElementType, ResultType>(\\n  mapper: (currentElement: ElementType) => ResultType,\\n  data: Mappable<ElementType>\\n): Mappable<ResultType> => data.map(mapper);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (currentElement: number) => String.fromCharCode(currentElement),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (\\n    accumulator: ResultType,\\n    currentElement: ElementType\\n  ) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The array containing data\\n  array: ElementType[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, currentElement: string) =>\\n      currentElement.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\ninterface Reducable<ElementType> {\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n  ): ResultType;\\n}\\n\\nclass _List<ElementType> implements Reducable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n\\n  ) {\\n    return this.value.reduce(reducer, initialValue);\\n  }\\n}\\n\\nconst reducePolymorphic = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (x: ResultType, y: ElementType) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The container containing data\\n  data: Reducable<ElementType>\\n) => data.reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reducePolymorphic(\\n\\n    // A reducer function\\n    (\\n      accumulator: number,\\n      currentElement: string\\n    ) => currentElement.charCodeAt(0) + accumulator,\\n\\n    // The initial value\\n    0,\\n\\n    // The container containing data\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"Another example is reduce\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"113:128 file=./polymorphism.ts title=\\\"Monomorphic Reduce\\\"\",\n    \"113:128\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Monomorphic\",\n    \"Reduce\\\"\": true\n  }), \"interface Appendable<ElementType> {\\n  append(\\n    end: Appendable<ElementType>\\n  ): Appendable<ElementType>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  beginning: Type,\\n  end: Type\\n): Type => beginning.append(end) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(end: _String): _String {\\n    return new _String(`${this.value}${end.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(end: _Number): _Number {\\n    return new _Number(this.value + end.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <ElementType, ResultType>(\\n\\n  // A mapping function\\n  mapper: (currentElement: ElementType) => ResultType,\\n\\n  // An array containing data\\n  array: ElementType[]\\n\\n): ResultType[] => [mapper(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (\\n      currentElement: number\\n    ) => String.fromCharCode(currentElement),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<ElementType> {\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (\\n      currentElement: ElementType\\n    ) => ResultType\\n\\n  ): Mappable<ResultType>;\\n}\\n\\nclass _List<ElementType> implements Mappable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (currentElement: ElementType) => ResultType\\n  ) {\\n    return this.value.map(mapper);\\n  }\\n\\n}\\n\\nconst mapPolymorphic = <ElementType, ResultType>(\\n  mapper: (currentElement: ElementType) => ResultType,\\n  data: Mappable<ElementType>\\n): Mappable<ResultType> => data.map(mapper);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (currentElement: number) => String.fromCharCode(currentElement),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (\\n    accumulator: ResultType,\\n    currentElement: ElementType\\n  ) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The array containing data\\n  array: ElementType[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, currentElement: string) =>\\n      currentElement.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\ninterface Reducable<ElementType> {\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n  ): ResultType;\\n}\\n\\nclass _List<ElementType> implements Reducable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n\\n  ) {\\n    return this.value.reduce(reducer, initialValue);\\n  }\\n}\\n\\nconst reducePolymorphic = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (x: ResultType, y: ElementType) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The container containing data\\n  data: Reducable<ElementType>\\n) => data.reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reducePolymorphic(\\n\\n    // A reducer function\\n    (\\n      accumulator: number,\\n      currentElement: string\\n    ) => currentElement.charCodeAt(0) + accumulator,\\n\\n    // The initial value\\n    0,\\n\\n    // The container containing data\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"Because the types are fully specified, our function implementation has too much wiggle room.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"129:138 file=./polymorphism.ts title=\\\"Monomorphic Reduce\\\"\",\n    \"129:138\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Monomorphic\",\n    \"Reduce\\\"\": true\n  }), \"interface Appendable<ElementType> {\\n  append(\\n    end: Appendable<ElementType>\\n  ): Appendable<ElementType>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  beginning: Type,\\n  end: Type\\n): Type => beginning.append(end) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(end: _String): _String {\\n    return new _String(`${this.value}${end.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(end: _Number): _Number {\\n    return new _Number(this.value + end.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <ElementType, ResultType>(\\n\\n  // A mapping function\\n  mapper: (currentElement: ElementType) => ResultType,\\n\\n  // An array containing data\\n  array: ElementType[]\\n\\n): ResultType[] => [mapper(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (\\n      currentElement: number\\n    ) => String.fromCharCode(currentElement),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<ElementType> {\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (\\n      currentElement: ElementType\\n    ) => ResultType\\n\\n  ): Mappable<ResultType>;\\n}\\n\\nclass _List<ElementType> implements Mappable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (currentElement: ElementType) => ResultType\\n  ) {\\n    return this.value.map(mapper);\\n  }\\n\\n}\\n\\nconst mapPolymorphic = <ElementType, ResultType>(\\n  mapper: (currentElement: ElementType) => ResultType,\\n  data: Mappable<ElementType>\\n): Mappable<ResultType> => data.map(mapper);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (currentElement: number) => String.fromCharCode(currentElement),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (\\n    accumulator: ResultType,\\n    currentElement: ElementType\\n  ) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The array containing data\\n  array: ElementType[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, currentElement: string) =>\\n      currentElement.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\ninterface Reducable<ElementType> {\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n  ): ResultType;\\n}\\n\\nclass _List<ElementType> implements Reducable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n\\n  ) {\\n    return this.value.reduce(reducer, initialValue);\\n  }\\n}\\n\\nconst reducePolymorphic = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (x: ResultType, y: ElementType) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The container containing data\\n  data: Reducable<ElementType>\\n) => data.reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reducePolymorphic(\\n\\n    // A reducer function\\n    (\\n      accumulator: number,\\n      currentElement: string\\n    ) => currentElement.charCodeAt(0) + accumulator,\\n\\n    // The initial value\\n    0,\\n\\n    // The container containing data\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"We can create another interface to represent the ability to reduce, or aggregate, the contents of a container.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"139:152 file=./polymorphism.ts title=\\\"Reducable Interface\\\"\",\n    \"139:152\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Reducable\",\n    \"Interface\\\"\": true\n  }), \"interface Appendable<ElementType> {\\n  append(\\n    end: Appendable<ElementType>\\n  ): Appendable<ElementType>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  beginning: Type,\\n  end: Type\\n): Type => beginning.append(end) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(end: _String): _String {\\n    return new _String(`${this.value}${end.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(end: _Number): _Number {\\n    return new _Number(this.value + end.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <ElementType, ResultType>(\\n\\n  // A mapping function\\n  mapper: (currentElement: ElementType) => ResultType,\\n\\n  // An array containing data\\n  array: ElementType[]\\n\\n): ResultType[] => [mapper(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (\\n      currentElement: number\\n    ) => String.fromCharCode(currentElement),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<ElementType> {\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (\\n      currentElement: ElementType\\n    ) => ResultType\\n\\n  ): Mappable<ResultType>;\\n}\\n\\nclass _List<ElementType> implements Mappable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (currentElement: ElementType) => ResultType\\n  ) {\\n    return this.value.map(mapper);\\n  }\\n\\n}\\n\\nconst mapPolymorphic = <ElementType, ResultType>(\\n  mapper: (currentElement: ElementType) => ResultType,\\n  data: Mappable<ElementType>\\n): Mappable<ResultType> => data.map(mapper);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (currentElement: number) => String.fromCharCode(currentElement),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (\\n    accumulator: ResultType,\\n    currentElement: ElementType\\n  ) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The array containing data\\n  array: ElementType[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, currentElement: string) =>\\n      currentElement.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\ninterface Reducable<ElementType> {\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n  ): ResultType;\\n}\\n\\nclass _List<ElementType> implements Reducable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n\\n  ) {\\n    return this.value.reduce(reducer, initialValue);\\n  }\\n}\\n\\nconst reducePolymorphic = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (x: ResultType, y: ElementType) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The container containing data\\n  data: Reducable<ElementType>\\n) => data.reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reducePolymorphic(\\n\\n    // A reducer function\\n    (\\n      accumulator: number,\\n      currentElement: string\\n    ) => currentElement.charCodeAt(0) + accumulator,\\n\\n    // The initial value\\n    0,\\n\\n    // The container containing data\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"Our \", mdx(Code, {\n    mdxType: \"Code\"\n  }, \"_List\"), \" class implements \", mdx(Code, {\n    mdxType: \"Code\"\n  }, \"Reducable\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"152:176 file=./polymorphism.ts title=\\\"Implementing Reducable\\\"\",\n    \"152:176\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Implementing\",\n    \"Reducable\\\"\": true\n  }), \"interface Appendable<ElementType> {\\n  append(\\n    end: Appendable<ElementType>\\n  ): Appendable<ElementType>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  beginning: Type,\\n  end: Type\\n): Type => beginning.append(end) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(end: _String): _String {\\n    return new _String(`${this.value}${end.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(end: _Number): _Number {\\n    return new _Number(this.value + end.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <ElementType, ResultType>(\\n\\n  // A mapping function\\n  mapper: (currentElement: ElementType) => ResultType,\\n\\n  // An array containing data\\n  array: ElementType[]\\n\\n): ResultType[] => [mapper(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (\\n      currentElement: number\\n    ) => String.fromCharCode(currentElement),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<ElementType> {\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (\\n      currentElement: ElementType\\n    ) => ResultType\\n\\n  ): Mappable<ResultType>;\\n}\\n\\nclass _List<ElementType> implements Mappable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (currentElement: ElementType) => ResultType\\n  ) {\\n    return this.value.map(mapper);\\n  }\\n\\n}\\n\\nconst mapPolymorphic = <ElementType, ResultType>(\\n  mapper: (currentElement: ElementType) => ResultType,\\n  data: Mappable<ElementType>\\n): Mappable<ResultType> => data.map(mapper);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (currentElement: number) => String.fromCharCode(currentElement),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (\\n    accumulator: ResultType,\\n    currentElement: ElementType\\n  ) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The array containing data\\n  array: ElementType[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, currentElement: string) =>\\n      currentElement.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\ninterface Reducable<ElementType> {\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n  ): ResultType;\\n}\\n\\nclass _List<ElementType> implements Reducable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n\\n  ) {\\n    return this.value.reduce(reducer, initialValue);\\n  }\\n}\\n\\nconst reducePolymorphic = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (x: ResultType, y: ElementType) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The container containing data\\n  data: Reducable<ElementType>\\n) => data.reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reducePolymorphic(\\n\\n    // A reducer function\\n    (\\n      accumulator: number,\\n      currentElement: string\\n    ) => currentElement.charCodeAt(0) + accumulator,\\n\\n    // The initial value\\n    0,\\n\\n    // The container containing data\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"We can define our polymorphic \", mdx(Code, {\n    mdxType: \"Code\"\n  }, \"reduce\"), \" like so\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"177:187 file=./polymorphism.ts title=\\\"Polymorphic Reduce\\\"\",\n    \"177:187\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Polymorphic\",\n    \"Reduce\\\"\": true\n  }), \"interface Appendable<ElementType> {\\n  append(\\n    end: Appendable<ElementType>\\n  ): Appendable<ElementType>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  beginning: Type,\\n  end: Type\\n): Type => beginning.append(end) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(end: _String): _String {\\n    return new _String(`${this.value}${end.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(end: _Number): _Number {\\n    return new _Number(this.value + end.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <ElementType, ResultType>(\\n\\n  // A mapping function\\n  mapper: (currentElement: ElementType) => ResultType,\\n\\n  // An array containing data\\n  array: ElementType[]\\n\\n): ResultType[] => [mapper(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (\\n      currentElement: number\\n    ) => String.fromCharCode(currentElement),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<ElementType> {\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (\\n      currentElement: ElementType\\n    ) => ResultType\\n\\n  ): Mappable<ResultType>;\\n}\\n\\nclass _List<ElementType> implements Mappable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (currentElement: ElementType) => ResultType\\n  ) {\\n    return this.value.map(mapper);\\n  }\\n\\n}\\n\\nconst mapPolymorphic = <ElementType, ResultType>(\\n  mapper: (currentElement: ElementType) => ResultType,\\n  data: Mappable<ElementType>\\n): Mappable<ResultType> => data.map(mapper);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (currentElement: number) => String.fromCharCode(currentElement),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (\\n    accumulator: ResultType,\\n    currentElement: ElementType\\n  ) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The array containing data\\n  array: ElementType[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, currentElement: string) =>\\n      currentElement.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\ninterface Reducable<ElementType> {\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n  ): ResultType;\\n}\\n\\nclass _List<ElementType> implements Reducable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n\\n  ) {\\n    return this.value.reduce(reducer, initialValue);\\n  }\\n}\\n\\nconst reducePolymorphic = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (x: ResultType, y: ElementType) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The container containing data\\n  data: Reducable<ElementType>\\n) => data.reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reducePolymorphic(\\n\\n    // A reducer function\\n    (\\n      accumulator: number,\\n      currentElement: string\\n    ) => currentElement.charCodeAt(0) + accumulator,\\n\\n    // The initial value\\n    0,\\n\\n    // The container containing data\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\"))), mdx(Step, {\n    mdxType: \"Step\"\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"We can be more confident this function does what it says.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"189:205 file=./polymorphism.ts title=\\\"Polymorphic Reduce\\\"\",\n    \"189:205\": true,\n    \"file\": \"./polymorphism.ts\",\n    \"title\": \"\\\"Polymorphic\",\n    \"Reduce\\\"\": true\n  }), \"interface Appendable<ElementType> {\\n  append(\\n    end: Appendable<ElementType>\\n  ): Appendable<ElementType>;\\n}\\n\\nconst appendPolymorphic = <Type extends Appendable<any>>(\\n  beginning: Type,\\n  end: Type\\n): Type => beginning.append(end) as Type;\\n\\nclass _String implements Appendable<string> {\\n  public value: string;\\n\\n  constructor(value: string) {\\n    this.value = value;\\n  }\\n\\n  append(end: _String): _String {\\n    return new _String(`${this.value}${end.value}`);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _String(\\\"hello, \\\"),\\n    new _String(\\\"how are you?\\\")\\n  ).value\\n);\\n// \\\"hello, how are you?\\\"\\n\\nclass _Number implements Appendable<number> {\\n  public value: number;\\n\\n  constructor(value: number) {\\n    this.value = value;\\n  }\\n\\n  append(end: _Number): _Number {\\n    return new _Number(this.value + end.value);\\n  }\\n}\\n\\nconsole.log(\\n  appendPolymorphic(\\n    new _Number(1),\\n    new _Number(1)\\n  ).value\\n);\\n// 2\\n\\nconst mapArray = <ElementType, ResultType>(\\n\\n  // A mapping function\\n  mapper: (currentElement: ElementType) => ResultType,\\n\\n  // An array containing data\\n  array: ElementType[]\\n\\n): ResultType[] => [mapper(array[0])];\\n\\nconsole.log(\\n  mapArray(\\n    (\\n      currentElement: number\\n    ) => String.fromCharCode(currentElement),\\n    [100, 101, 102]\\n  )\\n);\\n// [\\\"d\\\"]\\n\\ninterface Mappable<ElementType> {\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (\\n      currentElement: ElementType\\n    ) => ResultType\\n\\n  ): Mappable<ResultType>;\\n}\\n\\nclass _List<ElementType> implements Mappable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  map<ResultType>(\\n\\n    // A mapping function\\n    mapper: (currentElement: ElementType) => ResultType\\n  ) {\\n    return this.value.map(mapper);\\n  }\\n\\n}\\n\\nconst mapPolymorphic = <ElementType, ResultType>(\\n  mapper: (currentElement: ElementType) => ResultType,\\n  data: Mappable<ElementType>\\n): Mappable<ResultType> => data.map(mapper);\\n\\nconsole.log(\\n  mapPolymorphic(\\n    (currentElement: number) => String.fromCharCode(currentElement),\\n    new _List([100, 101, 102])\\n  )\\n);\\n// [\\\"d\\\", \\\"e\\\", \\\"f\\\"]\\n\\nconst reduceArray = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (\\n    accumulator: ResultType,\\n    currentElement: ElementType\\n  ) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The array containing data\\n  array: ElementType[]\\n) => array.slice(0, 1).reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reduceArray(\\n    (accumulator: number, currentElement: string) =>\\n      currentElement.charCodeAt(0) + accumulator,\\n    0,\\n    [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n  )\\n);\\n// 97\\n\\ninterface Reducable<ElementType> {\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n  ): ResultType;\\n}\\n\\nclass _List<ElementType> implements Reducable<ElementType> {\\n\\n  public value: ElementType[];\\n\\n  constructor(value: ElementType[]) {\\n    this.value = value;\\n  }\\n\\n  reduce<ResultType>(\\n\\n    // A reducer function\\n    reducer: (\\n      accumulator: ResultType,\\n      currentElement: ElementType\\n    ) => ResultType,\\n\\n    // The initial value\\n    initialValue: ResultType\\n\\n  ) {\\n    return this.value.reduce(reducer, initialValue);\\n  }\\n}\\n\\nconst reducePolymorphic = <ElementType, ResultType>(\\n\\n  // A reducer function\\n  reducer: (x: ResultType, y: ElementType) => ResultType,\\n\\n  // The initial value\\n  initialValue: ResultType,\\n\\n  // The container containing data\\n  data: Reducable<ElementType>\\n) => data.reduce(reducer, initialValue);\\n\\nconsole.log(\\n  reducePolymorphic(\\n\\n    // A reducer function\\n    (\\n      accumulator: number,\\n      currentElement: string\\n    ) => currentElement.charCodeAt(0) + accumulator,\\n\\n    // The initial value\\n    0,\\n\\n    // The container containing data\\n    new _List([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\\n  )\\n);\\n// 294\\n\")))), mdx(\"hr\", null), mdx(\"h1\", null, \"Why though?\"), mdx(\"ul\", null, mdx(Appear, {\n    mdxType: \"Appear\"\n  }, mdx(\"li\", null, \"Priotizes correctness\"), mdx(\"li\", null, \"Enables composition of logic structures\"), mdx(\"li\", null, \"Reduces duplication\"))), mdx(\"hr\", null), mdx(\"h1\", null, \"Limitations of TypeScript\"), mdx(\"ul\", null, mdx(Appear, {\n    mdxType: \"Appear\"\n  }, mdx(\"li\", null, \"No Typeclasses\"), mdx(\"li\", null, \"More verbose\"), mdx(\"li\", null, \"Requires use of \", mdx(Code, {\n    mdxType: \"Code\"\n  }, \"this\"), \" in classes\"))), mdx(\"hr\", null), mdx(\"h1\", null, \"Thank you!\"), mdx(\"p\", null, \"Questions?\"), mdx(\"h3\", null, \"Further Reading\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    href: \"http://degoes.net/articles/insufficiently-polymorphic\"\n  }, \"Insufficiently Polymorphic\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    href: \"https://soundcloud.com/lambda-cast/9-polymorphism-and-abstraction\"\n  }, \"Polymorphism and Abstraction\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    href: \"https://www.youtube.com/watch?v=BHjIl81HgfE\"\n  }, \"Add a Type Parameter\"))), mdx(\"hr\", null));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"matchPath":"/*","isCreatedByStatefulCreatePages":false,"id":"97c449b9-8404-5627-8399-2a245f6c4575","slug":"","title":"Polymorphism in TypeScript"}}}